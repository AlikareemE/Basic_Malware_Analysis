using System;
using System.Windows.Forms;
using Mono.Cecil;
using Mono.Cecil.Metadata;
using Mono.Cecil.PE;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Security.Cryptography;
using System.Reflection;
using System.Reflection.Metadata;
using System.Text.RegularExpressions;
using System.Net;
using System.Text;
using Newtonsoft.Json;
using System.Runtime.InteropServices;
using System.Reflection.PortableExecutable;
using PInvoke;

namespace Basic_Malware_Analysis
{
    public partial class PEFileAnalyzer : Form
    {
        private List<string> _functions = new List<string>();
        public PEFileAnalyzer()
        {
            InitializeComponent();
        }

        private void btnOpenFile_Click(object sender, EventArgs e)
        {



            OpenFileDialog ofd = new OpenFileDialog();
            ofd.Filter = "PE Files (*.exe, *.dll)|*.exe;*.dll|All Files (*.*)|*.*";

            if (ofd.ShowDialog() == DialogResult.OK)
            {


                txtFilePath.Text = ofd.FileName;
                FileStream fs = new FileStream(ofd.FileName, FileMode.Open, FileAccess.Read);
                BinaryReader br = new BinaryReader(fs);



                ////
                ///









                // Read the PE header
                fs.Seek(0x3C, SeekOrigin.Begin);
                int peHeaderOffset = br.ReadInt32();
                fs.Seek(peHeaderOffset, SeekOrigin.Begin);
                uint peSignature = br.ReadUInt32();

                if (peSignature != 0x4550)
                {
                    MessageBox.Show("Not a valid PE file.", "Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
                    return;
                }

                // Read the COFF header
                ushort machine = br.ReadUInt16();
                ushort numberOfSections = br.ReadUInt16();
                uint timestamp = br.ReadUInt32();
                uint pointerToSymbolTable = br.ReadUInt32();
                uint numberOfSymbols = br.ReadUInt32();
                ushort sizeOfOptionalHeader = br.ReadUInt16();
                ushort characteristics = br.ReadUInt16();
                // Read the optional header
                ushort magic = br.ReadUInt16();
                byte majorLinkerVersion = br.ReadByte();
                byte minorLinkerVersion = br.ReadByte();
                uint sizeOfCode = br.ReadUInt32();
                uint sizeOfInitializedData = br.ReadUInt32();
                uint sizeOfUninitializedData = br.ReadUInt32();
                uint addressOfEntryPoint = br.ReadUInt32();
                uint baseOfCode = br.ReadUInt32();
                uint baseOfData = br.ReadUInt32();
                uint imageBase = br.ReadUInt32();
                uint sectionAlignment = br.ReadUInt32();
                uint fileAlignment = br.ReadUInt32();
                ushort majorOperatingSystemVersion = br.ReadUInt16();
                ushort minorOperatingSystemVersion = br.ReadUInt16();
                ushort majorImageVersion = br.ReadUInt16();
                ushort minorImageVersion = br.ReadUInt16();
                ushort majorSubsystemVersion = br.ReadUInt16();
                ushort minorSubsystemVersion = br.ReadUInt16();
                uint win32VersionValue = br.ReadUInt32();
                uint sizeOfImage = br.ReadUInt32();
                uint sizeOfHeaders = br.ReadUInt32();
                uint checkSum = br.ReadUInt32();
                ushort subsystem = br.ReadUInt16();
                ushort dllCharacteristics = br.ReadUInt16();
                uint sizeOfStackReserve = br.ReadUInt32();



                header.Items.Add("machine :" + "0x" + machine.ToString("X"));
                header.Items.Add("numberOfSections : " + numberOfSections.ToString());
                header.Items.Add("timestamp :  " + "0x" + timestamp.ToString("X"));
                header.Items.Add("pointerToSymbolTable :  " + "0x" + pointerToSymbolTable.ToString("X"));
                header.Items.Add("numberOfSymbols :  " + numberOfSymbols.ToString());
                header.Items.Add("sizeOfOptionalHeader :  " + sizeOfOptionalHeader.ToString());
                header.Items.Add("magic :  " + magic.ToString(""));
                header.Items.Add("majorLinkerVersion :  " + majorLinkerVersion.ToString(""));
                header.Items.Add("minorLinkerVersion :  " + minorLinkerVersion.ToString(""));
                header.Items.Add("sizeOfCode :  " + sizeOfCode.ToString(""));
                header.Items.Add("sizeOfInitializedData :  " + sizeOfInitializedData.ToString(""));
                header.Items.Add("sizeOfUninitializedData :  " + sizeOfUninitializedData.ToString(""));
                header.Items.Add("addressOfEntryPoint :  " + addressOfEntryPoint.ToString(""));
                header.Items.Add("baseOfCode :  " + baseOfCode.ToString(""));
                header.Items.Add("imageBase :  " + imageBase.ToString(""));
                header.Items.Add("sectionAlignment :  " + sectionAlignment.ToString(""));
                header.Items.Add("fileAlignment :  " + fileAlignment.ToString(""));
                header.Items.Add("majorOperatingSystemVersion :  " + majorOperatingSystemVersion.ToString(""));
                header.Items.Add("minorOperatingSystemVersion :  " + minorOperatingSystemVersion.ToString(""));
                header.Items.Add("majorImageVersion :  " + majorImageVersion.ToString(""));
                header.Items.Add("minorImageVersion :  " + minorImageVersion.ToString(""));
                header.Items.Add("majorSubsystemVersion :  " + majorSubsystemVersion.ToString(""));
                header.Items.Add("minorSubsystemVersion :  " + minorSubsystemVersion.ToString(""));
                header.Items.Add("win32VersionValue :  " + win32VersionValue.ToString(""));
                header.Items.Add("checkSum :  " + checkSum.ToString(""));
                header.Items.Add("subsystem :  " + subsystem.ToString(""));
                header.Items.Add("sizeOfHeaders :  " + sizeOfHeaders.ToString(""));
                header.Items.Add("sizeOfImage :  " + sizeOfImage.ToString(""));
                header.Items.Add("sizeOfStackReserve :  " + sizeOfStackReserve.ToString(""));
                header.Items.Add("baseOfData :  " + baseOfData.ToString(""));
                header.Items.Add("dllCharacteristics :  " + dllCharacteristics.ToString(""));





                br.Close();
                fs.Close();
            }
        }


        private void btnExtractFunctions_Click(object sender, EventArgs e)
        {


            lstFunctions.Items.Clear();
            txtMD5.Text = "";


            string filePath = txtFilePath.Text;
            if (!System.IO.File.Exists(filePath))
            {
                MessageBox.Show($"Error: file '{filePath}' not found", "Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
                return;
            }

            try
            {
                using (var stream = File.OpenRead(filePath))
                {
                    var md5 = MD5.Create();
                    var sha1 = SHA1.Create();

                    txtMD5.Text = BitConverter.ToString(md5.ComputeHash(stream)).Replace("-", "");


                    stream.Seek(0, SeekOrigin.Begin);

                    var module = Mono.Cecil.ModuleDefinition.ReadModule(stream);
                    var functions = module.Types
                        .SelectMany(t => t.Methods)
                        .Where(m => !m.IsConstructor && !m.IsSpecialName && m.Body != null)
                        .ToList();

                    foreach (var function in functions)
                    {
                        lstFunctions.Items.Add(function.FullName);
                    }

                    MessageBox.Show($"Found   functions and calculated MD5   hashes in file '{filePath}'", "Success", MessageBoxButtons.OK, MessageBoxIcon.Information);
                }


                /////



                // Load the PE file into memory
                byte[] peFile = File.ReadAllBytes(txtFilePath.Text);

                // Create a new assembly definition
                Mono.Cecil.AssemblyDefinition assembly = Mono.Cecil.AssemblyDefinition.ReadAssembly(new MemoryStream(peFile));

                // Extract the referenced assemblies
                libraries.Items.Clear();
                foreach (var reference in assembly.MainModule.AssemblyReferences)
                {
                    libraries.Items.Add(reference.Name);
                }



                /////////////////////////


            }
            catch (Exception ex)
            {
                MessageBox.Show($"Error: failed to extract functions or calculate hashes from file '{filePath}': {ex.Message}", "Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
            }


        }

        private void button1_Click(object sender, EventArgs e)
        {

        }



        private void VirusTotalScanner_Click(object sender, EventArgs e)
        {

            // Get the hash from the text box
            string hash = txtMD5.Text;

            // Your VirusTotal API key
            string apiKey = "79923a57dfe9ca79f295df55fe5161823a0deb316be7f8a7b6eef9deea7fefc4";

            // Build the URL for scanning the hash
            string url = "https://www.virustotal.com/vtapi/v2/file/report";
            url += "?apikey=" + apiKey + "&resource=" + hash;

            // Create a web client for sending the request
            using (WebClient client = new WebClient())
            {
                try
                {
                    // Send the request and get the response as a byte array
                    byte[] response = client.DownloadData(url);

                    // Parse the response as a JSON string
                    string json = Encoding.UTF8.GetString(response);

                    // Convert the JSON string to a dynamic object
                    dynamic result = JsonConvert.DeserializeObject(json);

                    // Create a string builder to build the report
                    StringBuilder reportBuilder = new StringBuilder();

                    // Append the scan date and time
                    reportBuilder.Append("Scan Date: " + DateTime.Now.ToString() + "\n\n");

                    // Append the number of engines that detected the file as malicious
                    reportBuilder.Append("Engines Detected: " + result.positives + " / " + result.total + "\n\n");

                    // Append a list of engines that detected the file as malicious
                    reportBuilder.Append("Malicious Engines:\n");
                    foreach (var scanner in result.scans)
                    {
                        if ((bool)scanner.Value["detected"])
                        {
                            reportBuilder.Append("- " + scanner.Name + ": " + scanner.Value["result"] + "\n");
                        }

                    }
                    reportBuilder.Append("\n");

                    // Append a list of engines that did not detect the file as malicious
                    reportBuilder.Append("Clean Engines:\n");
                    foreach (var scanner in result.scans)
                    {
                        if (!(scanner.Value["detected"].ToObject<bool>()))
                        {
                            reportBuilder.Append("- " + scanner.Name + "\n");
                        }
                    }

                    // Display the scan results in the result text box
                    resultTextBox.Text = reportBuilder.ToString();
                }
                catch (WebException ex)
                {
                    MessageBox.Show("An error occurred while scanning the hash:\n\n" + ex.Message, "Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
                }
            }

        }

        private void PEFileAnalyzer_Load(object sender, EventArgs e)
        {

        }

        private void btnExtractStrings_Click(object sender, EventArgs e)
        {
            if (!File.Exists(txtFilePath.Text))
            {
                MessageBox.Show("File not found!", "Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
                return;
            }

            List<string> strings = new List<string>();
            using (FileStream fileStream = new FileStream(txtFilePath.Text, FileMode.Open, FileAccess.Read))
            using (PEReader peReader = new PEReader(fileStream))
            {
                foreach (SectionHeader sectionHeader in peReader.PEHeaders.SectionHeaders)
                {
                    if (sectionHeader.SizeOfRawData == 0) continue; // skip empty sections

                    byte[] sectionData = new byte[sectionHeader.SizeOfRawData];
                    fileStream.Seek(sectionHeader.PointerToRawData, SeekOrigin.Begin);
                    fileStream.Read(sectionData, 0, sectionData.Length);

                    string sectionString = Encoding.ASCII.GetString(sectionData);
                    string[] sectionStrings = sectionString.Split('\0');

                    foreach (string str in sectionStrings)
                    {
                        if (!string.IsNullOrWhiteSpace(str))
                        {
                            strings.Add(str);
                        }
                    }
                }
            }

            listBoxStrings.Items.Clear();
            listBoxStrings.Items.AddRange(strings.ToArray());
        }
        [DllImport("dnsapi.dll", EntryPoint = "DnsQuery_W", ExactSpelling = true, CharSet = CharSet.Unicode)]
        private static extern int DnsQuery([MarshalAs(UnmanagedType.LPWStr)] string pszName, DnsQueryTypes wType, DnsQueryOptions options, IntPtr pExtra, out IntPtr ppQueryResultsSet, IntPtr pReserved);

        private enum DnsQueryTypes
        {
            DNS_TYPE_A = 0x0001, // IPv4 address
            DNS_TYPE_NS = 0x0002, // Name server
            DNS_TYPE_CNAME = 0x0005, // Canonical name for an alias
            DNS_TYPE_PTR = 0x000C, // Pointer to a canonical name
            DNS_TYPE_MX = 0x000F, // Mail exchange
            DNS_TYPE_AAAA = 0x001C // IPv6 address
        }

        [Flags]
        public enum DnsQueryOptions : uint
        {
            None = 0x00000000,
            Standard = 0x00000000,
            CacheOnly = 0x00000001,
            NoRecursion = 0x00000002,
            BypassCache = 0x00000008,
            NoWireQuery = 0x00000010,
            NoLocalName = 0x00000020,
            NoHostsFile = 0x00000040,
            TreatAsFqdn = 0x00000080,
            DontResetTtlValues = 0x00100000,
            AllowEmptyAuthority = 0x01000000,
            AppendMultilabel = 0x02000000,
            DontAddDefName = 0x04000000,
            DontUseSearchList = 0x08000000,
            NoMulticast = 0x10000000,
            TreatAsAlias = 0x20000000,
            AddressConfig = 0x40000000,
            DualAddress = 0x80000000
        }
        private void btnExtractNetwork_Click(object sender, EventArgs e)
        {
            if (!string.IsNullOrEmpty(txtFilePath.Text))
            {
                List<string> ips = new List<string>();
                List<string> domains = new List<string>();

                try
                {
                    byte[] fileBytes = System.IO.File.ReadAllBytes(txtFilePath.Text);
                    int startIndex = BitConverter.ToInt32(fileBytes, 0x3C);
                    int sectionCount = BitConverter.ToInt16(fileBytes, startIndex + 6);

                    int offset = startIndex + 24;
                    for (int i = 0; i < sectionCount; i++)
                    {
                        string sectionName = Encoding.ASCII.GetString(fileBytes, offset, 8).Replace("\0", "");
                        int virtualSize = BitConverter.ToInt32(fileBytes, offset + 8);
                        int virtualAddress = BitConverter.ToInt32(fileBytes, offset + 12);
                        byte[] sectionBytes = new byte[virtualSize];
                        Array.Copy(fileBytes, virtualAddress, sectionBytes, 0, virtualSize);
                        string sectionString = Encoding.ASCII.GetString(sectionBytes);

                        // Find IP addresses in section
                        listIP.Items.Clear();
                        foreach (IPAddress ipAddress in FindIPAddresses(sectionString))
                        {
                            ips.Add(ipAddress.ToString());
                        }

                        // Find domains in section
                        listIP.Items.Clear();
                        foreach (string domain in FindDomains(sectionString))
                        {
                            domains.Add(domain);
                        }

                        offset += 40;
                    }

                    // Display results
                    listIP.Items.Clear();
                    listIP.Items.Add("IP Addresses:");
                    foreach (string ip in ips.Distinct())
                    {
                        listIP.Items.Add(ip);
                    }

                    listIP.Items.Add("");
                    listIP.Items.Add("Domains:");
                    foreach (string domain in domains.Distinct())
                    {
                        listIP.Items.Add(domain);
                    }

                    MessageBox.Show("Done", "Results");
                }
                catch (Exception ex)
                {
                    MessageBox.Show(ex.Message, "Error");
                }
            }
        }
        private List<IPAddress> FindIPAddresses(string inputString)
        {
            List<IPAddress> ipAddresses = new List<IPAddress>();
            string[] words = inputString.Split(new[] { ' ', '\t', '\r', '\n', '\f', '\v', ':' }, StringSplitOptions.RemoveEmptyEntries);
            foreach (string word in words)
            {
                IPAddress ipAddress;
                if (IPAddress.TryParse(word, out ipAddress))
                {
                    ipAddresses.Add(ipAddress);
                }
            }
            return ipAddresses;
        }

        private List<string> FindDomains(string inputString)
        {
            List<string> domains = new List<string>();
            string[] words = inputString.Split(new[] { ' ', '\t', '\r', '\n', '\f', '\v', ':', '.', '/', '\\' }, StringSplitOptions.RemoveEmptyEntries);
            foreach (string word in words)
            {
                if (Uri.CheckHostName(word) != UriHostNameType.Unknown)
                {
                    domains.Add(word);
                }
                else if (word.Contains("."))
                {
                    // Check if it's a top-level domain
                    string[] tlds = { "com", "edu", "gov", "int", "mil", "net", "org" };
                    string[] parts = word.Split('.');
                    if (parts.Length == 2 && tlds.Contains(parts[1]))
                    {
                        domains.Add(word);
                    }
                }
            }
            return domains;
        }
    }
}
